# üöÄ Upstox-Style Notifications Backtest (1H) ‚Äî 30 days, parallel, API hook
!pip install yfinance pandas numpy tqdm -q

import yfinance as yf
import pandas as pd
import numpy as np
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm.notebook import tqdm
import datetime as dt

# ---------------- CONFIG ----------------
INTERVAL = "1h"                  # Upstox uses 1H in your screenshots
LOOKBACK_SWING = 12              # swing window for breakout/breakdown
BARS_PER_DAY = 7                 # ~6-7 hourly bars in NSE per day
VOL_WINDOW = 10 * BARS_PER_DAY   # "10-day average volume" baseline
VOL_MULT = 1.6                   # >= 1.6x spike (matches your alerts)
HOLD_BARS = 3                    # hold 3 hours in backtest
MAX_WORKERS = 16                 # parallel workers
SAVE = True
# ---- Upstox API (optional hook) ----
USE_UPSTOX_API = False           # set True if you have SDK + tokens installed
UPSTOX_ACCESS_TOKEN = ""         # put your token here if using API
# -------------------------------------

# --------- Load OFFICIAL NIFTY100 (no dummies) ----------
nse_url = "https://archives.nseindia.com/content/indices/ind_nifty100list.csv"
n100 = pd.read_csv(nse_url)
symbols = (n100["Symbol"].astype(str).str.strip() + ".NS").tolist()

# Clean duplicates and any accidental leftovers in session
symbols = sorted(set(s for s in symbols if ".NS" in s and "DUMMY" not in s.upper()))
print(f"üîç Loaded {len(symbols)} NIFTY 100 symbols.")

# --------- FAST batch download: last 30 days, 1H ----------
print("‚è¨ Downloading last 30 days 1H OHLCV in one batch ‚Ä¶")
raw = yf.download(
    tickers=" ".join(symbols),
    interval=INTERVAL,
    period="30d",                 # <-- 30 days
    group_by="ticker",
    auto_adjust=False,
    threads=True,
    progress=False,
)

def get_df(t):
    """Return clean df for ticker, IST indexed, or None."""
    try:
        df = raw[t].dropna().copy()
    except Exception:
        return None
    # Flatten unexpected multiindex
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
    # Ensure numeric
    for c in ["Open","High","Low","Close","Volume"]:
        df[c] = pd.to_numeric(df[c], errors="coerce")
    df = df.dropna(subset=["Open","High","Low","Close","Volume"])
    if df.empty:
        return None
    # To IST safely (tz-aware or naive)
    try:
        if df.index.tz is None:
            df.index = df.index.tz_localize("UTC").tz_convert("Asia/Kolkata")
        else:
            df.index = df.index.tz_convert("Asia/Kolkata")
    except Exception:
        pass
    return df

# Build a slim dict of only those symbols that actually returned data
data = {}
for t in symbols:
    d = get_df(t)
    if d is not None and len(d) >= max(LOOKBACK_SWING, VOL_WINDOW) + 5:
        data[t] = d
print(f"‚úÖ Got usable data for {len(data)} symbols.")

# ---------- Upstox-notification logic (from your screenshots) ----------
def crosses_above(prev_close, curr_close, level):
    return (prev_close <= level) and (curr_close > level)

def crosses_below(prev_close, curr_close, level):
    return (prev_close >= level) and (curr_close < level)

def analyze_symbol(sym, df):
    """
    Returns: {
      'summary': {...},
      'alerts': [ ... ]  # alert dicts
    }
    """
    df = df.copy()
    # swing levels based on previous range, slight slack like Upstox notifications
    df["SwingHigh"] = df["High"].rolling(LOOKBACK_SWING).max() * 0.995
    df["SwingLow"]  = df["Low"].rolling(LOOKBACK_SWING).min()  * 1.005

    # 10-day baseline on 1H bars
    df["AvgVol10d"] = df["Volume"].rolling(VOL_WINDOW).mean()
    df["VolRatio"]  = df["Volume"] / df["AvgVol10d"]

    # Candle quality
    df["Range"]    = df["High"] - df["Low"]
    df["AvgRange"] = df["Range"].rolling(LOOKBACK_SWING).mean()

    alerts = []
    trades = []

    start_i = int(max(LOOKBACK_SWING, VOL_WINDOW)) + 1
    for i in range(start_i, len(df) - HOLD_BARS):
        prev_c = df["Close"].iloc[i-1]
        cur_c  = df["Close"].iloc[i]
        hh     = df["SwingHigh"].iloc[i-1]  # use prev bar level ‚Üí true cross on current bar
        ll     = df["SwingLow"].iloc[i-1]
        vr     = df["VolRatio"].iloc[i]
        rng    = df["Range"].iloc[i]
        arng   = df["AvgRange"].iloc[i]
        o      = df["Open"].iloc[i]
        ts     = df.index[i]

        strong_bull = (cur_c > o) or (rng > arng if not np.isnan(arng) else False)
        strong_bear = (cur_c < o) or (rng > arng if not np.isnan(arng) else False)

        # --------- Bullish breakout + volume spike ----------
        if crosses_above(prev_c, cur_c, hh) and (vr >= VOL_MULT) and strong_bull:
            entry_t = df.index[i+1]
            entry_p = df["Open"].iloc[i+1]
            exit_t  = df.index[i+HOLD_BARS]
            exit_p  = df["Close"].iloc[i+HOLD_BARS]
            pnl     = (exit_p - entry_p) / entry_p * 100.0
            alerts.append({
                "Symbol": sym.replace(".NS",""),
                "When(IST)": ts,
                "Type": "Price Breakout + Volume Spike (1H)",
                "Level": round(hh,2),
                "Close": round(cur_c,2),
                "Vol x 10d": round(vr,2)
            })
            trades.append(pnl)

        # --------- Bearish breakdown + volume spike ----------
        if crosses_below(prev_c, cur_c, ll) and (vr >= VOL_MULT) and strong_bear:
            entry_t = df.index[i+1]
            entry_p = df["Open"].iloc[i+1]
            exit_t  = df.index[i+HOLD_BARS]
            exit_p  = df["Close"].iloc[i+HOLD_BARS]
            pnl     = (entry_p - exit_p) / entry_p * 100.0
            alerts.append({
                "Symbol": sym.replace(".NS",""),
                "When(IST)": ts,
                "Type": "Price Breakdown + Volume Spike (1H)",
                "Level": round(ll,2),
                "Close": round(cur_c,2),
                "Vol x 10d": round(vr,2)
            })
            trades.append(pnl)

    # Summary (Streak-style)
    if trades:
        arr = np.array(trades, dtype=float)
        wins = arr[arr > 0]; losses = arr[arr <= 0]
        summary = {
            "Symbol": sym.replace(".NS",""),
            "Trades": int(len(arr)),
            "Win %": round(len(wins)/len(arr)*100, 1),
            "Avg Gain %": round(arr.mean(), 2),
            "Net P&L %": round(arr.sum(), 2),
            "Profit Factor": round(abs(wins.sum()/losses.sum()), 2) if len(losses) and losses.sum()!=0 else float("inf"),
        }
    else:
        summary = {
            "Symbol": sym.replace(".NS",""), "Trades": 0,
            "Win %": 0.0, "Avg Gain %": 0.0, "Net P&L %": 0.0, "Profit Factor": 0.0
        }

    return {"summary": summary, "alerts": alerts}

# ---------- Parallel run ----------
print("üßÆ Scanning in parallel ‚Ä¶")
summaries, alerts_all = [], []

with ThreadPoolExecutor(max_workers=MAX_WORKERS) as ex:
    futures = {ex.submit(analyze_symbol, sym, df): sym for sym, df in data.items()}
    for fut in tqdm(as_completed(futures), total=len(futures)):
        try:
            out = fut.result()
            summaries.append(out["summary"])
            alerts_all.extend(out["alerts"])
        except Exception as e:
            pass

# ---------- Outputs ----------
summary_df = pd.DataFrame(summaries).sort_values(["Trades","Net P&L %"], ascending=[False, False])
alerts_df  = pd.DataFrame(alerts_all).sort_values("When(IST)")

print("\nüìä Summary (last 30 days, 1H):")
display(summary_df.head(30))

if alerts_df.empty:
    print("‚ö™ No Upstox-style alerts with current thresholds in last 30 days.")
else:
    print(f"üîî Found {len(alerts_df)} Upstox-style alerts. Latest 15:")
    display(alerts_df.tail(15))
    print("\nüìù Notification-style lines:")
    for _, r in alerts_df.tail(10).iterrows():
        if "Breakout" in r["Type"]:
            print(f"{r['Symbol']}: Price Breakout + Volume Spike (1H) ‚Äî breaks above ‚Çπ{r['Level']} "
                  f"with trading activity ~{r['Vol x 10d']}√ó vs 10-day average. [{r['When(IST)']:%Y-%m-%d %H:%M}]")
        else:
            print(f"{r['Symbol']}: Price Breakdown + Volume Spike (1H) ‚Äî slips below ‚Çπ{r['Level']} "
                  f"with trading activity ~{r['Vol x 10d']}√ó vs 10-day average. [{r['When(IST)']:%Y-%m-%d %H:%M}]")

if SAVE:
    summary_df.to_csv("nifty100_upstox_backtest_1h_30d_summary.csv", index=False)
    alerts_df.to_csv("nifty100_upstox_alerts_1h_30d.csv", index=False)
    print("\nüìÅ Saved: nifty100_upstox_backtest_1h_30d_summary.csv, nifty100_upstox_alerts_1h_30d.csv")

# ---------- Optional: Upstox API hook ----------
if USE_UPSTOX_API:
    try:
        # NOTE: SDK/package names change; this is a safe placeholder hook.
        # Replace with your working SDK import & place-order code.
        from upstox_api.api import Upstox, Session  # may fail if package not installed
        print("üîó Upstox SDK available. Ready to send live alerts/orders (hook points below).")
        # Example hook (pseudo):
        # u = Upstox(APP_KEY, UPSTOX_ACCESS_TOKEN)
        # for _, row in alerts_df.tail(5).iterrows():
        #     # place a paper order / real order:
        #     # u.place_order(...)
        #     pass
    except Exception as e:
